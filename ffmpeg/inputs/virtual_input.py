from typing import Literal, Optional
from .file_input import BaseInput
from ..utils import build_name_kvargs_format


class VirtualInput(BaseInput):
    def __init__(self, name: str, format: str = "lavfi",  **kwargs) -> None:
        super().__init__()
        self.name = name
        self.format_flag = format
        self.kwargs = kwargs

    @property
    def input_flag(self) -> str:
        return build_name_kvargs_format(self.name, self.kwargs)

    def build(self) -> list:
        return ["-f", self.format_flag, "-i", self.input_flag]

    # ---------------------- VIDEO SOURCES ----------------------

    @classmethod
    def cellauto(
        cls,
        height: int,
        width: int,
        pattern: Optional[int] = None,
        rate: Optional[int] = None,
        random_fill_ratio: Optional[float] = None,
        random_seed: Optional[int] = None,
        rule: Optional[int] = None,
        scroll: Optional[bool] = None,
        start_full: Optional[bool] = None,
        stitch: Optional[bool] = None,
    ):
        """
        Create a pattern generated by an elementary cellular automaton.
        The initial state of the cellular automaton can be defined through the filename and pattern options. If such options are not specified an initial state is created randomly.
        At each new frame a new row in the video is filled with the result of the cellular automaton next generation. The behavior when the whole frame is filled is defined by the scroll option.

        https://ffmpeg.org/ffmpeg-filters.html#cellauto
        """

        local_vars = locals()
        kwargs = {}
        for k, v in local_vars.items():
            if k in {"cls", "height", "width"} and v is None:
                continue

            if isinstance(v, bool):
                v = bool(v)

            kwargs.update(k=v)

        return cls("cellauto", size=f"{width}x{height}", **kwargs)

    @classmethod
    def life(
        cls,
        size: str = "320x240",
        rate: int = 30,
        mold: int = 0,
        stitch: int = 1,
        duration: int = None,
    ):
        kwargs = {"size": size, "rate": rate, "mold": mold, "stitch": stitch}
        if duration:
            kwargs["duration"] = duration
        return cls("life", **kwargs)

    @classmethod
    def mandelbrot(
        cls,
        width: int = 640,
        height: int = 480,
        end_pts: Optional[int] = None,
        end_scale: Optional[float] = None,
        inner: Optional[str] = None,
        bailout: Optional[float] = None,
        maxiter: Optional[int] = None,
        outer: Optional[str] = None,
        rate: Optional[int] = None,
        start_scale: Optional[float] = None,
        start_x: Optional[float] = None,
        start_y: Optional[float] = None,
    ):
        """
        Generate a Mandelbrot set fractal with zoom animation.

        https://ffmpeg.org/ffmpeg-filters.html#mandelbrot
        """
        local_vars = locals()
        kwargs = {
            k: v
            for k, v in local_vars.items()
            if k not in {"cls", "width", "height"} and v is not None
        }
        return cls("mandelbrot", size=f"{width}x{height}", **kwargs)

    @classmethod
    def gradients(
        cls,
        width: int = 640,
        height: int = 480,
        rate: Optional[int] = None,
        c0: Optional[str] = None,
        c1: Optional[str] = None,
        c2: Optional[str] = None,
        c3: Optional[str] = None,
        c4: Optional[str] = None,
        c5: Optional[str] = None,
        c6: Optional[str] = None,
        c7: Optional[str] = None,
        x0: Optional[int] = None,
        y0: Optional[int] = None,
        x1: Optional[int] = None,
        y1: Optional[int] = None,
        nb_colors: Optional[int] = None,
        seed: Optional[int] = None,
        duration: Optional[str] = None,
        speed: Optional[float] = None,
        type: Optional[
            Literal[
                "linear",
                "radial",
                "circular",
                "spiral",
                "square",
            ]
        ] = None, 
    ):
        """
        Generate several animated gradients.

        https://ffmpeg.org/ffmpeg-filters.html#gradients
        """
        local_vars = locals()
        kwargs = {
            k: v
            for k, v in local_vars.items()
            if k not in {"cls", "width", "height"} and v is not None
        }
        return cls("gradients", size=f"{width}x{height}", **kwargs)

    # ---------------------- VIDEO FILTER EFFECTS ----------------------

    @classmethod
    def mirror(cls, size: str = "640x480", duration: int = None):
        return cls(
            "testsrc", size=size, duration=duration
        )  # Apply mirror as filter in pipeline

    @classmethod
    def lut_separate_channels(cls, size: str = "640x480", duration: int = None):
        return cls("testsrc", size=size, duration=duration)  # Use lut filter after

    @classmethod
    def histogram(cls, size: str = "640x480", duration: int = None):
        return cls("testsrc", size=size, duration=duration)  # Add histogram filter

    @classmethod
    def vectorscope(cls, size: str = "640x480", duration: int = None):
        return cls("testsrc", size=size, duration=duration)  # Add vectorscope filter

    @classmethod
    def waveform(cls, size: str = "640x480", duration: int = None):
        return cls("testsrc", size=size, duration=duration)  # Add waveform filter

    @classmethod
    def waveform_envelope(cls, size: str = "640x480", duration: int = None):
        return cls(
            "testsrc", size=size, duration=duration
        )  # Add waveform=display=overlay:mode=envelope

    @classmethod
    def datascope(cls, size: str = "640x480", duration: int = None):
        return cls("testsrc", size=size, duration=duration)  # Add datascope filter

    # ---------------------- AUDIO SOURCES ----------------------

    @classmethod
    def aevalsrc(cls, exprs: str = "sin(2*PI*440*t)", duration: float = None):
        kwargs = {"exprs": exprs}
        if duration:
            kwargs["duration"] = duration
        return cls("aevalsrc", **kwargs)

    # ---------------------- AUDIO FILTER VISUALS ----------------------

    @classmethod
    def showwaves(cls, duration: int = 5):
        return cls("sine", frequency=440, duration=duration)  # Add showwaves filter

    @classmethod
    def showspectrum(cls, duration: int = 5):
        return cls("sine", frequency=440, duration=duration)  # Add showspectrum filter

    @classmethod
    def avectorscope(cls, duration: int = 5):
        return cls("sine", frequency=440, duration=duration)  # Add avectorscope

    @classmethod
    def showcqt(cls, duration: int = 5):
        return cls("sine", frequency=440, duration=duration)  # Add showcqt

    @classmethod
    def showspectrumpic(cls, duration: int = 5):
        return cls("sine", frequency=440, duration=duration)  # Add showspectrumpic

    @classmethod
    def showcwt(cls, duration: int = 5):
        return cls("sine", frequency=440, duration=duration)  # Add showcwt
