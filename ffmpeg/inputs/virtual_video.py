from typing import Any, Literal, Optional

from .base_virtual_input import BaseVirtualInput


class VirtualVideo(BaseVirtualInput):
    """ ssdsad"""

    def __init__(
        self,
        name: str,
        format: str = "lavfi",
        flags: Optional[dict[str, Any]] = None,
        **kwargs,
    ) -> None:
        super().__init__(name=name, format=format, flags=flags, **kwargs)

    @classmethod
    def from_cellauto(
        cls,
        width: int,
        height: int,
        pattern: Optional[int] = None,
        rate: Optional[int] = None,
        random_fill_ratio: Optional[float] = None,
        random_seed: Optional[int] = None,
        rule: Optional[int] = None,
        scroll: Optional[bool] = None,
        start_full: Optional[bool] = None,
        stitch: Optional[bool] = None,
    ):
        """
        Create a pattern generated by an elementary cellular automaton.
        The initial state of the cellular automaton can be defined through the filename and pattern options. If such options are not specified an initial state is created randomly.
        At each new frame a new row in the video is filled with the result of the cellular automaton next generation. The behavior when the whole frame is filled is defined by the scroll option.

        https://ffmpeg.org/ffmpeg-filters.html#cellauto
        """

        local_vars = locals()
        kwargs = {}
        for k, v in local_vars.items():
            if k in {"cls", "height", "width"}:
                continue


            kwargs.update(k=v)

        return cls("cellauto", size=f"{width}x{height}", **kwargs)

    @classmethod
    def from_life(
        cls,
        width: int,
        height: int,
        duration: Optional[float] = None,
        rate: int = 30,
        mold: int = 0,
        stitch: int = 1,
        rule: Optional[str] = None,
    ):
        local_vars = locals()
        kwargs = {
            k: v
            for k, v in local_vars.items()
            if k not in {"cls", "width", "height", "duration"}
        }
        return cls(
            "life",
            size=f"{width}x{height}",
            flags=dict(t=duration),  # this filter does not take duration like normal
            **kwargs,
        )

    @classmethod
    def from_mandelbrot(
        cls,
        width: int = 640,
        height: int = 480,
        rate: Optional[int] = None,
        end_pts: Optional[int] = None,
        end_scale: Optional[float] = None,
        inner: Optional[str] = None,
        bailout: Optional[float] = None,
        maxiter: Optional[int] = None,
        outer: Optional[str] = None,
        start_scale: Optional[float] = None,
        start_x: Optional[float] = None,
        start_y: Optional[float] = None,
    ):
        """
        Generate a Mandelbrot set fractal with zoom animation.

        https://ffmpeg.org/ffmpeg-filters.html#mandelbrot
        """
        local_vars = locals()
        kwargs = {
            k: v
            for k, v in local_vars.items()
            if k not in {"cls", "width", "height"}
        }
        return cls("mandelbrot", size=f"{width}x{height}", **kwargs)

    @classmethod
    def from_gradients(
        cls,
        height: int,
        width: int,
        duration: Optional[float] = None,
        rate: Optional[int] = None,
        c0: Optional[str] = None,
        c1: Optional[str] = None,
        c2: Optional[str] = None,
        c3: Optional[str] = None,
        c4: Optional[str] = None,
        c5: Optional[str] = None,
        c6: Optional[str] = None,
        c7: Optional[str] = None,
        x0: Optional[int] = None,
        y0: Optional[int] = None,
        x1: Optional[int] = None,
        y1: Optional[int] = None,
        nb_colors: Optional[int] = None,
        seed: Optional[int] = None,
        speed: Optional[float] = None,
        type: Optional[
            Literal[
                "linear",
                "radial",
                "circular",
                "spiral",
                "square",
            ]
        ] = None,
    ):
        """
        Generate several animated gradients.

        https://ffmpeg.org/ffmpeg-filters.html#gradients
        """
        local_vars = locals()
        kwargs = {
            k: v
            for k, v in local_vars.items()
            if k not in {"cls", "width", "height"}
        }
        return cls("gradients", size=f"{width}x{height}", **kwargs)

    @classmethod
    def from_testsrc(
        cls,
        width: int,
        height: int,
        duration: Optional[float] = None,
        rate: int = 25,
        sar: Optional[int] = None,
        decimals: Optional[int] = None,
    ):
        """
        size : set video size (default "320x240")
        rate : set video rate (default "25")
        duration : set video duration (default -0.000001)
        sar : set video sample aspect ratio (from 0 to INT_MAX) (default 1/1)
        decimals : set number of decimals to show (from 0 to 17) (default 0)
        """
        local_vars = locals()
        kwargs = {
            k: v
            for k, v in local_vars.items()
            if k not in {"cls", "width", "height"}
        }
        return cls("testsrc", size=f"{width}x{height}", **kwargs)

    @classmethod
    def from_testsrc2(
        cls,
        height: int,
        width: int,
        duration: Optional[float] = None,
        rate: int = 25,
        sar: Optional[int] = None,
        alpha: Optional[int] = None,
    ):
        local_vars = locals()
        kwargs = {
            k: v
            for k, v in local_vars.items()
            if k not in {"cls", "width", "height"}
        }
        return cls("testsrc2", size=f"{width}x{height}", **kwargs)

    @classmethod
    def from_smptehdbars(
        cls,
        height: int,
        width: int,
        duration: Optional[float] = None,
        rate: int = 25,
        sar: Optional[int] = None,
    ):
        local_vars = locals()
        kwargs = {
            k: v
            for k, v in local_vars.items()
            if k not in {"cls", "width", "height"}
        }
        return cls("smptehdbars", size=f"{width}x{height}", **kwargs)

    @classmethod
    def from_smptebars(
        cls,
        height: int,
        width: int,
        duration: Optional[float] = None,
        rate: int = 25,
        sar: Optional[int] = None,
    ):
        local_vars = locals()
        kwargs = {
            k: v
            for k, v in local_vars.items()
            if k not in {"cls", "width", "height"}
        }
        return cls("smptebars", size=f"{width}x{height}", **kwargs)

    @classmethod
    def from_sierpinski(
        cls,
        width: int,
        height: int,
        duration: Optional[float] = None,
        rate: int = 25,
        from_sierpinski: Optional[int] = None,
        type: Optional[Literal["carpet", "triangle"]] = None,
        seed: Optional[int] = None,
    ):
        local_vars = locals()
        kwargs = {
            k: v
            for k, v in local_vars.items()
            if k not in {"cls", "width", "height", "duration"}
        }
        return cls(
            "sierpinski",
            size=f"{width}x{height}",
            flags=dict(t=duration),  # this filter does not take duration like normal
            **kwargs,
        )

    @classmethod
    def from_ddagrab(
        cls,
        output_idx: int,
        draw_mouse: Optional[bool] = None,
        framerate: Optional[bool] = None,
        rate: int = 25,
        sar: Optional[int] = None,
        preset: Optional[Literal["reference", "skintones"]] = None,
        seed: Optional[int] = None,
    ):
        """
        output_idx        <int>        ..FV....... dda output index to capture (from 0 to INT_MAX) (default 0)
    draw_mouse        <boolean>    ..FV....... draw the mouse pointer (default true)
    framerate         <video_rate> ..FV....... set video frame rate (default "30")
    video_size        <image_size> ..FV....... set video frame size
    offset_x          <int>        ..FV....... capture area x offset (from INT_MIN to INT_MAX) (default 0)
    offset_y          <int>        ..FV....... capture area y offset (from INT_MIN to INT_MAX) (default 0)
    output_fmt        <int>        ..FV....... desired output format (from 0 to INT_MAX) (default 8bit)
        auto            0            ..FV....... let dda pick its preferred format
        8bit            87           ..FV....... only output default 8 Bit format
        bgra            87           ..FV....... only output 8 Bit BGRA
        10bit           24           ..FV....... only output default 10 Bit format
        x2bgr10         24           ..FV....... only output 10 Bit X2BGR10
        16bit           10           ..FV....... only output default 16 Bit format
        rgbaf16         10           ..FV....... only output 16 Bit RGBAF16
    allow_fallback    <boolean>    ..FV....... don't error on fallback to default 8 Bit format (default false)
    force_fmt         <boolean>    ..FV....... exclude BGRA from format list (experimental, discouraged by Microsoft) (default false)
        
        """
        local_vars = locals()
        kwargs = {
            k: v
            for k, v in local_vars.items()
            if k not in {"cls", "tile_width", "tile_height"}
        }
        return cls(
            "colorchart",
            patch_size=f"{tile_width}x{tile_height}",
            _size=f"{tile_width * 6}x{tile_height * 4}",
            **kwargs,
        )

    @classmethod
    def from_colorchart(
        cls,
        tile_width: int,
        tile_height: int,
        duration: Optional[float] = None,
        rate: int = 25,
        sar: Optional[int] = None,
        preset: Optional[Literal["reference", "skintones"]] = None,
        seed: Optional[int] = None,
    ):

        local_vars = locals()
        kwargs = {
            k: v
            for k, v in local_vars.items()
            if k not in {"cls", "tile_width", "tile_height"}
        }
        return cls(
            "colorchart",
            patch_size=f"{tile_width}x{tile_height}",
            _size=f"{tile_width * 6}x{tile_height * 4}",
            **kwargs,
        )
