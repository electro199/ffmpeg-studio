{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FFmpeg.py","text":"<p>FFmpeg.py is a Pythonic interface to FFmpeg, designed to simplify the construction and execution of FFmpeg commands. It allows developers and power users to build complex audio/video processing pipelines in a more readable and flexible way.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Clean, chainable API to compose FFmpeg commands</li> <li>Automatic escaping of command-line arguments</li> <li>Support for both simple and advanced filter graphs</li> <li>Easily integrated into larger video processing workflows</li> <li>Support for progress callback function</li> </ul>"},{"location":"#ffprobe-and-ffplay","title":"FFprobe and FFplay","text":"<p>Alongside <code>ffmpeg.py</code>, this toolkit may also include convenient wrappers for:</p>"},{"location":"#ffprobe","title":"<code>ffprobe</code>","text":"<p>A Python wrapper for the <code>ffprobe</code> utility to extract metadata from media files.</p>"},{"location":"#ffplay","title":"<code>ffplay</code>","text":"<p>A Python wrapper for  <code>ffplay</code> for previewing media via Python.</p>"},{"location":"api/","title":"API Reference","text":"<p>This module provides methods to build and run FFmpeg with fine control commands.</p> <p>For simple usecase use <code>utils.export</code></p> <p>Use FFplay through easy to use function</p> <p>Use FFprobe through easy to use function or use flags to get specific data</p>"},{"location":"api/#ffmpeg.ffmpeg.FFmpeg","title":"<code>FFmpeg</code>","text":"<p>FFmpeg Command Builder</p> Source code in <code>ffmpeg\\ffmpeg.py</code> <pre><code>class FFmpeg:\n    \"\"\"FFmpeg Command Builder\"\"\"\n\n    def __init__(self) -&gt; None:\n\n        self.ffmpeg_path = \"ffmpeg\"\n        self._inputs: list[BaseInput] = []\n        self._filter_nodes = []\n        self._outputs: list[OutFile] = []\n        self.node_count = 0\n        self._global_flags = [\"-hide_banner\"]\n\n    def reset(self) -&gt; \"FFmpeg\":\n        \"\"\"Reset all compilation data added\"\"\"\n        self._inputs: list[BaseInput] = []\n        self._filter_nodes: list[BaseFilter] = []\n        self.node_count = 0\n        return self\n\n    def add_global_flag(self, *flags) -&gt; \"FFmpeg\":\n        \"\"\"Adds additional FFmpeg flags\"\"\"\n        self._global_flags.extend(flags)\n        return self\n\n    def handle_input_export(self, node: BaseInput | StreamSpecifier) -&gt; bool:\n        \"\"\"Check if Output is Input without any filter applied\"\"\"\n        if isinstance(node, StreamSpecifier):\n            node = node.parent\n\n        if isinstance(node, BaseInput):\n            if node not in self._inputs:\n                self._inputs.append(node)\n            return True\n        return False\n\n    def generate_link_name(self, i, j, stream_char=\"\") -&gt; str:\n        \"\"\"\n        make names for link names\n\n        Note: stream_char should not be use in outlink name generation\n        \"\"\"\n        return f\"n{i}o{j}{stream_char}\"\n\n    def generate_inlink_name(self, parent) -&gt; str:\n        \"\"\"Get different types of links that ffmpeg uses with different types of Object\"\"\"\n        stream_specifier = \"\"\n\n        if isinstance(parent, StreamSpecifier):\n            stream_specifier = parent.build_stream_str()\n            output_n = parent.output_number\n            parent = parent.parent\n\n        if isinstance(parent, BaseInput):\n            input_name = f\"{self._inputs.index(parent)}{stream_specifier}\"  # idx\n        else:\n            input_name = self.generate_link_name(\n                self._filter_nodes.index(parent), output_n, stream_specifier\n            )\n        return input_name\n\n    def build_filter(\n        self, last_node: BaseInput | StreamSpecifier\n    ) -&gt; list[Any] | Literal[\"\"]:\n        \"\"\"Builds the final FFmpeg chains\"\"\"\n\n        # If the output is Base Input return no need to add a filter\n        if self.handle_input_export(last_node):\n            return \"\"\n\n        self._inputs_tmp: list[BaseInput] = []\n        flat_graph: list[BaseFilter] | None = self.flatten_graph(last_node)\n\n        if flat_graph is None:\n            return \"\"\n\n        self._filter_nodes.extend(flat_graph[::-1])\n        self._inputs.extend(self._inputs_tmp[::-1])\n\n        filter_chain = []\n\n        for filter in flat_graph[::-1]:\n\n            filter_block = \"\"\n\n            # gather parents\n            for parent in filter.parent_nodes:\n                filter_block += wrap_sqrtbrkt(self.generate_inlink_name(parent))\n\n            # gather args\n            filter_block += filter.build()\n\n            # gather outlink\n            for j in range(filter.output_count):\n                filter_block += wrap_sqrtbrkt(\n                    self.generate_link_name(self.node_count, j)\n                )\n\n            self.node_count += 1\n            filter_chain.append(filter_block)\n\n        return filter_chain\n\n    def flatten_graph(\n        self, node: BaseFilter | StreamSpecifier  # type: ignore\n    ) -&gt; list[BaseFilter] | None:\n\n        if isinstance(node, StreamSpecifier):\n            node: BaseFilter | BaseInput = node.parent\n\n        if isinstance(node, BaseInput):\n            if node not in self._inputs_tmp:\n                self._inputs_tmp.append(node)\n            return\n\n        if isinstance(node, BaseFilter):\n            if node in self._filter_nodes:\n                return\n\n        nodes = [node]\n\n        for parent_node in node.parent_nodes:\n            nn = self.flatten_graph(parent_node)\n            if nn:\n                nodes.extend(nn)\n\n        return nodes\n\n    def build_inputs(self) -&gt; list[str]:\n\n        sub_command = []\n        for inp in self._inputs:\n            sub_command.extend(inp.build_input_flags())\n        return sub_command\n\n    def build_map(\n        self, map: Map, map_index\n    ) -&gt; tuple[Literal[\"-map\"], str, *tuple[Any, ...]]:\n\n        node = map.node\n        stream = self.generate_inlink_name(node)\n\n        if isinstance(node, StreamSpecifier):\n            node = node.parent\n\n        if not isinstance(node, BaseInput):\n            stream = wrap_sqrtbrkt(stream)\n\n        flags = []\n\n        # use stream type like foo:v \n        stream_type_specfier = f\":{map.stream_type}\" if map.stream_type else \"\"\n\n        for k, v in map.suffix_flags.items():\n            flags.append(f\"-{k}{stream_type_specfier}:{map_index}\")\n            flags.append(str(v))\n\n        for k, v in map.flags.items():\n            flags.append(f\"-{k}\")\n            flags.append(str(v))\n\n        return (\"-map\", stream, *flags)\n\n    def compile(self, overwrite=True) -&gt; list[str]:\n        \"\"\"\n        Generate the command\n        This fuction gather and combine all of the different part of the command.\n\n        command structure should be like:\n            `ffmpeg [global flags] [input flags -i input] [-filter_complex [filter]] [-map streamid output flags output]`\n\n        \"\"\"\n\n        if len(self._outputs) &lt; 1:\n            raise RuntimeError()\n        self.reset()\n\n        if overwrite:\n            self.add_global_flag(\"-y\")\n        else:\n            self.add_global_flag(\"-n\")\n\n        self.add_global_flag(\"-loglevel\", \"error\")\n\n\n        command = [self.ffmpeg_path, *self._global_flags]\n        # First flatten filters to add inputs automatically from last node order matters here\n        filters = []\n        for output in self._outputs:\n            for map_ in output.maps:\n                filters.extend(self.build_filter(map_.node))\n\n        if inputs := self.build_inputs():\n            command.extend(inputs)\n\n        if filters:\n            command.extend((\"-filter_complex\", \";\".join(filters)))\n\n        for output in self._outputs:\n            for i, maps in enumerate(output.maps): # one output can have multiple maps\n                command.extend(self.build_map(maps, i))\n\n            command.extend(build_flags(output.kvflags))\n            command.append(output.path)\n\n        return list(map(str, command))\n\n    def output(self, *maps, path, **kvflags) -&gt; \"FFmpeg\":\n        \"\"\"Create output for the command with map and output specific flags and the path for the output\"\"\"\n        self._outputs.append(OutFile(maps, path, **kvflags))\n        return self\n\n    def run(\n        self,\n        progress_callback: Optional[Callable[[dict], None]] = None,\n        progress_period: float = 0.5,\n        overwrite: bool = True,\n    ) -&gt; None:\n        \"\"\"\n        Run the FFmpeg command.\n\n        Args:\n            progress_callback: a function that can be used to track progress of the process running data can be mix of N/A and actual values\n            progress_period: Set period at which progress_callback is called\n            overwrite: overwrite the output if already exists\n\n        \"\"\"\n\n        stdout = None\n        stderr = subprocess.PIPE\n\n        # If progress_callback: function is provided capture the outputs\n        if progress_callback:\n            stdout = subprocess.PIPE\n            self.add_global_flag(\"-progress\", \"pipe:1\", \"-nostats\")\n            self.add_global_flag(\"-stats_period\", progress_period)\n\n        command = self.compile(overwrite=overwrite)\n        logger.debug(f\"Running: {command}\")  # Debugging output\n\n        # Start FFmpeg process\n        process = subprocess.Popen(\n            command,\n            stdout=stdout,\n            stderr=stderr,\n            universal_newlines=True,\n            bufsize=1,\n        )\n\n        if progress_callback:\n            assert process.stdout is not None\n\n            # Read progress data\n            progress_data = {}\n\n            for line in iter(process.stdout.readline, \"\"):\n                line = line.strip()\n                if \"=\" in line:\n                    key, value = line.split(\"=\", 1)\n                    progress_data[key] = parse_value(value.strip())\n\n                if \"progress\" in progress_data:\n                    if progress_callback:\n                        progress_callback(progress_data)\n                    progress_data.clear()  # Reset for next update\n\n            process.stdout.close()\n        process.wait()  # Ensure process completes\n\n        if process.returncode != 0:\n            raise FFmpegException(process.stderr.read(), process.returncode)\n</code></pre>"},{"location":"api/#ffmpeg.ffmpeg.FFmpeg.add_global_flag","title":"<code>add_global_flag(*flags)</code>","text":"<p>Adds additional FFmpeg flags</p> Source code in <code>ffmpeg\\ffmpeg.py</code> <pre><code>def add_global_flag(self, *flags) -&gt; \"FFmpeg\":\n    \"\"\"Adds additional FFmpeg flags\"\"\"\n    self._global_flags.extend(flags)\n    return self\n</code></pre>"},{"location":"api/#ffmpeg.ffmpeg.FFmpeg.build_filter","title":"<code>build_filter(last_node)</code>","text":"<p>Builds the final FFmpeg chains</p> Source code in <code>ffmpeg\\ffmpeg.py</code> <pre><code>def build_filter(\n    self, last_node: BaseInput | StreamSpecifier\n) -&gt; list[Any] | Literal[\"\"]:\n    \"\"\"Builds the final FFmpeg chains\"\"\"\n\n    # If the output is Base Input return no need to add a filter\n    if self.handle_input_export(last_node):\n        return \"\"\n\n    self._inputs_tmp: list[BaseInput] = []\n    flat_graph: list[BaseFilter] | None = self.flatten_graph(last_node)\n\n    if flat_graph is None:\n        return \"\"\n\n    self._filter_nodes.extend(flat_graph[::-1])\n    self._inputs.extend(self._inputs_tmp[::-1])\n\n    filter_chain = []\n\n    for filter in flat_graph[::-1]:\n\n        filter_block = \"\"\n\n        # gather parents\n        for parent in filter.parent_nodes:\n            filter_block += wrap_sqrtbrkt(self.generate_inlink_name(parent))\n\n        # gather args\n        filter_block += filter.build()\n\n        # gather outlink\n        for j in range(filter.output_count):\n            filter_block += wrap_sqrtbrkt(\n                self.generate_link_name(self.node_count, j)\n            )\n\n        self.node_count += 1\n        filter_chain.append(filter_block)\n\n    return filter_chain\n</code></pre>"},{"location":"api/#ffmpeg.ffmpeg.FFmpeg.compile","title":"<code>compile(overwrite=True)</code>","text":"<p>Generate the command This fuction gather and combine all of the different part of the command.</p> command structure should be like <p><code>ffmpeg [global flags] [input flags -i input] [-filter_complex [filter]] [-map streamid output flags output]</code></p> Source code in <code>ffmpeg\\ffmpeg.py</code> <pre><code>def compile(self, overwrite=True) -&gt; list[str]:\n    \"\"\"\n    Generate the command\n    This fuction gather and combine all of the different part of the command.\n\n    command structure should be like:\n        `ffmpeg [global flags] [input flags -i input] [-filter_complex [filter]] [-map streamid output flags output]`\n\n    \"\"\"\n\n    if len(self._outputs) &lt; 1:\n        raise RuntimeError()\n    self.reset()\n\n    if overwrite:\n        self.add_global_flag(\"-y\")\n    else:\n        self.add_global_flag(\"-n\")\n\n    self.add_global_flag(\"-loglevel\", \"error\")\n\n\n    command = [self.ffmpeg_path, *self._global_flags]\n    # First flatten filters to add inputs automatically from last node order matters here\n    filters = []\n    for output in self._outputs:\n        for map_ in output.maps:\n            filters.extend(self.build_filter(map_.node))\n\n    if inputs := self.build_inputs():\n        command.extend(inputs)\n\n    if filters:\n        command.extend((\"-filter_complex\", \";\".join(filters)))\n\n    for output in self._outputs:\n        for i, maps in enumerate(output.maps): # one output can have multiple maps\n            command.extend(self.build_map(maps, i))\n\n        command.extend(build_flags(output.kvflags))\n        command.append(output.path)\n\n    return list(map(str, command))\n</code></pre>"},{"location":"api/#ffmpeg.ffmpeg.FFmpeg.generate_inlink_name","title":"<code>generate_inlink_name(parent)</code>","text":"<p>Get different types of links that ffmpeg uses with different types of Object</p> Source code in <code>ffmpeg\\ffmpeg.py</code> <pre><code>def generate_inlink_name(self, parent) -&gt; str:\n    \"\"\"Get different types of links that ffmpeg uses with different types of Object\"\"\"\n    stream_specifier = \"\"\n\n    if isinstance(parent, StreamSpecifier):\n        stream_specifier = parent.build_stream_str()\n        output_n = parent.output_number\n        parent = parent.parent\n\n    if isinstance(parent, BaseInput):\n        input_name = f\"{self._inputs.index(parent)}{stream_specifier}\"  # idx\n    else:\n        input_name = self.generate_link_name(\n            self._filter_nodes.index(parent), output_n, stream_specifier\n        )\n    return input_name\n</code></pre>"},{"location":"api/#ffmpeg.ffmpeg.FFmpeg.generate_link_name","title":"<code>generate_link_name(i, j, stream_char='')</code>","text":"<p>make names for link names</p> <p>Note: stream_char should not be use in outlink name generation</p> Source code in <code>ffmpeg\\ffmpeg.py</code> <pre><code>def generate_link_name(self, i, j, stream_char=\"\") -&gt; str:\n    \"\"\"\n    make names for link names\n\n    Note: stream_char should not be use in outlink name generation\n    \"\"\"\n    return f\"n{i}o{j}{stream_char}\"\n</code></pre>"},{"location":"api/#ffmpeg.ffmpeg.FFmpeg.handle_input_export","title":"<code>handle_input_export(node)</code>","text":"<p>Check if Output is Input without any filter applied</p> Source code in <code>ffmpeg\\ffmpeg.py</code> <pre><code>def handle_input_export(self, node: BaseInput | StreamSpecifier) -&gt; bool:\n    \"\"\"Check if Output is Input without any filter applied\"\"\"\n    if isinstance(node, StreamSpecifier):\n        node = node.parent\n\n    if isinstance(node, BaseInput):\n        if node not in self._inputs:\n            self._inputs.append(node)\n        return True\n    return False\n</code></pre>"},{"location":"api/#ffmpeg.ffmpeg.FFmpeg.output","title":"<code>output(*maps, path, **kvflags)</code>","text":"<p>Create output for the command with map and output specific flags and the path for the output</p> Source code in <code>ffmpeg\\ffmpeg.py</code> <pre><code>def output(self, *maps, path, **kvflags) -&gt; \"FFmpeg\":\n    \"\"\"Create output for the command with map and output specific flags and the path for the output\"\"\"\n    self._outputs.append(OutFile(maps, path, **kvflags))\n    return self\n</code></pre>"},{"location":"api/#ffmpeg.ffmpeg.FFmpeg.reset","title":"<code>reset()</code>","text":"<p>Reset all compilation data added</p> Source code in <code>ffmpeg\\ffmpeg.py</code> <pre><code>def reset(self) -&gt; \"FFmpeg\":\n    \"\"\"Reset all compilation data added\"\"\"\n    self._inputs: list[BaseInput] = []\n    self._filter_nodes: list[BaseFilter] = []\n    self.node_count = 0\n    return self\n</code></pre>"},{"location":"api/#ffmpeg.ffmpeg.FFmpeg.run","title":"<code>run(progress_callback=None, progress_period=0.5, overwrite=True)</code>","text":"<p>Run the FFmpeg command.</p> <p>Parameters:</p> Name Type Description Default <code>progress_callback</code> <code>Optional[Callable[[dict], None]]</code> <p>a function that can be used to track progress of the process running data can be mix of N/A and actual values</p> <code>None</code> <code>progress_period</code> <code>float</code> <p>Set period at which progress_callback is called</p> <code>0.5</code> <code>overwrite</code> <code>bool</code> <p>overwrite the output if already exists</p> <code>True</code> Source code in <code>ffmpeg\\ffmpeg.py</code> <pre><code>def run(\n    self,\n    progress_callback: Optional[Callable[[dict], None]] = None,\n    progress_period: float = 0.5,\n    overwrite: bool = True,\n) -&gt; None:\n    \"\"\"\n    Run the FFmpeg command.\n\n    Args:\n        progress_callback: a function that can be used to track progress of the process running data can be mix of N/A and actual values\n        progress_period: Set period at which progress_callback is called\n        overwrite: overwrite the output if already exists\n\n    \"\"\"\n\n    stdout = None\n    stderr = subprocess.PIPE\n\n    # If progress_callback: function is provided capture the outputs\n    if progress_callback:\n        stdout = subprocess.PIPE\n        self.add_global_flag(\"-progress\", \"pipe:1\", \"-nostats\")\n        self.add_global_flag(\"-stats_period\", progress_period)\n\n    command = self.compile(overwrite=overwrite)\n    logger.debug(f\"Running: {command}\")  # Debugging output\n\n    # Start FFmpeg process\n    process = subprocess.Popen(\n        command,\n        stdout=stdout,\n        stderr=stderr,\n        universal_newlines=True,\n        bufsize=1,\n    )\n\n    if progress_callback:\n        assert process.stdout is not None\n\n        # Read progress data\n        progress_data = {}\n\n        for line in iter(process.stdout.readline, \"\"):\n            line = line.strip()\n            if \"=\" in line:\n                key, value = line.split(\"=\", 1)\n                progress_data[key] = parse_value(value.strip())\n\n            if \"progress\" in progress_data:\n                if progress_callback:\n                    progress_callback(progress_data)\n                progress_data.clear()  # Reset for next update\n\n        process.stdout.close()\n    process.wait()  # Ensure process completes\n\n    if process.returncode != 0:\n        raise FFmpegException(process.stderr.read(), process.returncode)\n</code></pre>"},{"location":"api/#ffmpeg.ffmpeg.export","title":"<code>export(*nodes, path)</code>","text":"<p>Exports a clip by processing the given input nodes and saving the output to the specified path.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>BaseInput | StreamSpecifier</code> <p>One or more input nodes representing media sources.</p> <code>()</code> <code>path</code> <code>str</code> <p>The output file path where the exported clip will be saved.</p> required <p>Returns:</p> Name Type Description <code>FFmpeg</code> <code>FFmpeg</code> <p>An FFmpeg instance configured with the given inputs and output path.</p> Source code in <code>ffmpeg\\ffmpeg.py</code> <pre><code>def export(*nodes:BaseInput | StreamSpecifier, path: str) -&gt; FFmpeg:\n    \"\"\"\n    Exports a clip by processing the given input nodes and saving the output to the specified path.\n\n    Args:\n        nodes: One or more input nodes representing media sources.\n        path: The output file path where the exported clip will be saved.\n\n    Returns:\n        FFmpeg: An FFmpeg instance configured with the given inputs and output path.\n    \"\"\"\n    return FFmpeg().output(*(Map(node) for node in nodes), path=path)\n</code></pre>"},{"location":"api/#ffmpeg.inputs.FileInputOptions","title":"<code>FileInputOptions</code>","text":"<p>               Bases: <code>BaseOptions</code></p> <p>Represents input options for FFmpeg's <code>-i</code> flag.</p> <p>This class allows users to specify various input-related parameters for FFmpeg command generation. </p> Note <p>The types for flags like <code>duration</code> are int but ffmpeg can accept multiple formats. see ffmpeg</p> <p>Example usage: <pre><code>options = InputOptions(duration=10, start_time=\"00:00:05\", format=\"mp4\", frame_rate=30)\n</code></pre></p> Source code in <code>ffmpeg\\inputs\\options\\file_input_option.py</code> <pre><code>class FileInputOptions(BaseOptions):\n    \"\"\"\n    Represents input options for FFmpeg's `-i` flag.\n\n    This class allows users to specify various input-related parameters\n    for FFmpeg command generation. \n\n    Note:\n        The types for flags like `duration` are int but ffmpeg can accept multiple formats. see [ffmpeg](https://ffmpeg.org/ffmpeg-utils.html#Time-duration)\n\n    Example usage:\n    ```python\n    options = InputOptions(duration=10, start_time=\"00:00:05\", format=\"mp4\", frame_rate=30)\n    ```\n    \"\"\"\n\n    def __init__(\n        self,\n        duration: Optional[int] = None,\n        start_time: Optional[str] = None,\n        format: Optional[str] = None,\n        codec: Optional[str] = None,\n        frame_rate: Optional[float] = None,\n        video_size: Optional[str] = None,\n        pixel_format: Optional[str] = None,\n        sample_rate: Optional[int] = None,\n        audio_channels: Optional[int] = None,\n        thread_queue_size: Optional[int] = None,\n        itsoffset: Optional[float] = None,\n        itsoverride: Optional[bool] = None,\n        analyzeduration: Optional[int] = None,\n        probesize: Optional[int] = None,\n        rtbufsize: Optional[str] = None,\n        re: Optional[bool] = None,\n        accurate_seek: Optional[bool] = None,\n        discard: Optional[str] = None,\n        vsync: Optional[str] = None,\n        async_audio: Optional[int] = None,\n        fps_mode: Optional[str] = None,\n        loop: Optional[bool] = None,\n    ) -&gt; None:\n        super().__init__()\n        \"\"\"\n        Initialize input options for FFmpeg.\n\n        :param duration: Set the input duration (in seconds).\n        :param start_time: Seek to a specific time in the input file (format: HH:MM:SS or seconds).\n        :param format: Specify input format (e.g., \"mp4\", \"avi\").\n        :param codec: Specify input codec (e.g., \"h264\", \"aac\").\n        :param frame_rate: Set frame rate for the input (e.g., 30, 60).\n        :param video_size: Set resolution (e.g., \"1920x1080\").\n        :param pixel_format: Specify pixel format (e.g., \"yuv420p\").\n        :param sample_rate: Set audio sample rate in Hz (e.g., 44100).\n        :param audio_channels: Set number of audio channels (e.g., 2 for stereo).\n        :param thread_queue_size: Set the thread queue size for input processing.\n        :param itsoffset: Set input timestamp offset (in seconds).\n        :param itsoverride: Override input timestamps.\n        :param analyzeduration: Set maximum duration to analyze (in microseconds).\n        :param probesize: Set maximum amount of data to probe (bytes).\n        :param rtbufsize: Set real-time buffer size (e.g., \"100M\").\n        :param re: Read input at native frame rate.\n        :param accurate_seek: Enable accurate seeking.\n        :param discard: Discard specific input streams (e.g., \"none\", \"all\").\n        :param vsync: Set video sync method (e.g., \"cfr\", \"vfr\").\n        :param async_audio: Set audio sync method.\n        :param fps_mode: Set FPS mode (e.g., \"passthrough\", \"cfr\").\n        :param loop: Enable Looping always use with duration (e.g., 1 for infinite loop, 0 no loop).\n\n        Example usage:\n        ```python\n        options = InputOptions(duration=10, start_time=\"00:00:05\", format=\"mp4\", frame_rate=30)\n        ```\n        \"\"\"\n\n        if duration:\n            self.kwargs.update({\"t\": duration})\n        if start_time:\n            self.kwargs.update({\"ss\": start_time})\n        if format:\n            self.kwargs.update({\"f\": format})\n        if codec:\n            self.kwargs.update({\"c:v\": codec})\n        if frame_rate:\n            self.kwargs.update({\"r\": frame_rate})\n\n        if video_size:\n            self.kwargs.update({\"s\": video_size})\n\n        if pixel_format:\n            self.kwargs.update({\"pix_fmt\": pixel_format})\n        if sample_rate:\n            self.kwargs.update({\"ar\": sample_rate})\n        if audio_channels:\n            self.kwargs.update({\"ac\": audio_channels})\n        if thread_queue_size:\n            self.kwargs.update({\"thread_queue_size\": thread_queue_size})\n        if itsoffset:\n            self.kwargs.update({\"itsoffset\": itsoffset})\n\n        if analyzeduration:\n            self.kwargs.update({\"analyzeduration\": analyzeduration})\n        if probesize:\n            self.kwargs.update({\"probesize\": probesize})\n        if rtbufsize:\n            self.kwargs.update({\"rtbufsize\": rtbufsize})\n\n        if discard:\n            self.kwargs.update({\"discard\": discard})\n\n        if vsync:\n            self.kwargs.update({\"vsync\": vsync})\n        if async_audio:\n            self.kwargs.update({\"async\": async_audio})\n        if fps_mode:\n            self.kwargs.update({\"fps_mode\": fps_mode})\n\n        if loop:\n            self.kwargs.update({\"loop\": int(loop)})\n\n        if re:\n            self.args.append(\"re\")\n        if accurate_seek:\n            self.args.append(\"accurate_seek\")\n        if itsoverride:\n            self.args.append(\"itsoverride\")\n\n    def add_flags(self, key, value):\n        \"\"\"\n        Add other FFMPEG flags\n        \"\"\"\n        self.kwargs.update(key=value)\n</code></pre>"},{"location":"api/#ffmpeg.inputs.FileInputOptions.add_flags","title":"<code>add_flags(key, value)</code>","text":"<p>Add other FFMPEG flags</p> Source code in <code>ffmpeg\\inputs\\options\\file_input_option.py</code> <pre><code>def add_flags(self, key, value):\n    \"\"\"\n    Add other FFMPEG flags\n    \"\"\"\n    self.kwargs.update(key=value)\n</code></pre>"},{"location":"api/#ffmpeg.inputs.InputFile","title":"<code>InputFile</code>","text":"<p>               Bases: <code>BaseInput</code></p> <p>General Input for FFMPEG backend You can use custom flags</p> Source code in <code>ffmpeg\\inputs\\file_input.py</code> <pre><code>class InputFile(BaseInput):\n    \"\"\"\n    General Input for FFMPEG backend You can use custom flags\n    \"\"\"\n\n    def __init__(\n        self, filepath: str, options: Optional[FileInputOptions] = None\n    ) -&gt; None:\n        self.filepath = filepath\n        self.options = options\n\n    def build_input_flags(self) -&gt; list[str]:\n        command = []\n        if self.options:\n            command.extend(self.options.build())\n        command.extend([\"-i\", self.filepath])\n        return command\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;InputFile {self.filepath}&gt;\"\n\n    @property\n    def audio(self):\n        return StreamSpecifier(self, stream_name=\"a\")\n\n    @property\n    def video(self):\n        return StreamSpecifier(self, stream_name=\"v\")\n\n    def get_stream(\n        self,\n        stream_index: int,\n        stream_name: Optional[Literal[\"a\", \"v\", \"s\"]] = None,\n    ) -&gt; StreamSpecifier:\n        return StreamSpecifier(self, stream_name=stream_name, stream_index=stream_index)\n</code></pre>"},{"location":"api/#ffmpeg.inputs.StreamSpecifier","title":"<code>StreamSpecifier</code>","text":"<p>Used specify in ffmpeg command</p> <p>ffmpeg docs : https://ffmpeg.org/ffmpeg.html#toc-Automatic-stream-selection</p> Source code in <code>ffmpeg\\inputs\\streams.py</code> <pre><code>class StreamSpecifier:\n    \"\"\"\n    Used specify in ffmpeg command\n\n    ffmpeg docs : https://ffmpeg.org/ffmpeg.html#toc-Automatic-stream-selection\n    \"\"\"\n\n    __slots__ = (\n        \"parent\",\n        \"stream_index\",\n        \"stream_name\",\n        \"output_number\",\n    )\n\n    def __init__(\n        self,\n        parent,\n        output_index=0,\n        stream_index: Optional[int] = None,\n        stream_name: Optional[Literal[\"a\", \"v\", \"s\"]] = None,\n    ) -&gt; None:\n        self.parent = parent\n        self.stream_index = stream_index\n        self.stream_name = stream_name\n        self.output_number = output_index\n\n    def build_stream_str(self):\n        s = \"\"\n        if self.stream_name:\n            s += \":\" + str(self.stream_name)\n\n        if self.stream_index is not None:\n            s += \":\" + str(self.stream_index)\n\n        return s\n\n    def get_outputs(self):\n        return StreamSpecifier(self)\n</code></pre>"},{"location":"api/#ffmpeg.inputs.VideoFile","title":"<code>VideoFile</code>","text":"<p>               Bases: <code>BaseInput</code></p> <p>A class representing a video file that can be processed with FFmpeg.</p> <p>This class provides methods for interacting with a video file, such as  building FFmpeg input flags, extracting streams (audio, video, subtitles), creating subclips, and retrieving the video file's resolution.</p> Source code in <code>ffmpeg\\inputs\\video.py</code> <pre><code>class VideoFile(BaseInput):\n    \"\"\"\n    A class representing a video file that can be processed with FFmpeg.\n\n    This class provides methods for interacting with a video file, such as \n    building FFmpeg input flags, extracting streams (audio, video, subtitles),\n    creating subclips, and retrieving the video file's resolution.\n    \"\"\"\n\n    def __init__(self, filepath: str) -&gt; None:\n        \"\"\"\n        Initializes the VideoFile object with the specified file path.\n\n        Args:\n            filepath (str): The path to the video file to be processed.\n        \"\"\"\n        super().__init__()\n        self.filepath = filepath\n    @property\n    def audio(self) -&gt; StreamSpecifier:\n        \"\"\"\n        Access the audio stream of the video file.\n\n        Returns:\n            StreamSpecifier: A StreamSpecifier object for the audio stream.\n        \"\"\"\n        return StreamSpecifier(self, stream_name=\"a\")\n\n    @property\n    def video(self) -&gt; StreamSpecifier:\n        \"\"\"\n        Access the video stream of the video file.\n\n        Returns:\n            StreamSpecifier: A StreamSpecifier object for the video stream.\n        \"\"\"\n        return StreamSpecifier(self, stream_name=\"v\")\n\n    @property\n    def subtitle(self) -&gt; StreamSpecifier:\n        \"\"\"\n        Access the subtitle stream of the video file.\n\n        Returns:\n            StreamSpecifier: A StreamSpecifier object for the subtitle stream.\n        \"\"\"\n        return StreamSpecifier(self, stream_name=\"s\")\n\n    def get_stream(\n        self,\n        stream_index: int,\n        stream_name: Optional[Literal[\"a\", \"v\", \"s\"]] = None,\n    ) -&gt; StreamSpecifier:\n        \"\"\"\n        Get a specific stream from the video file by index and/or stream name. \n\n        Example:\n            You get 2nd audio stream from video like this. \n            ```python \n            clip.get_stream(stream_index=1,stream_name=\"a\")\n            ```\n\n        Args:\n            stream_index (int): The index of the stream (e.g., 0 for the first stream).\n            stream_name (Optional[Literal[\"a\", \"v\", \"s\"]]): The name of the stream \n                to retrieve (\"a\" for audio, \"v\" for video, \"s\" for subtitles). \n                If not provided, retrieves the stream by index.\n\n        Returns:\n            StreamSpecifier: A StreamSpecifier object for the requested stream.\n        \"\"\"\n        return StreamSpecifier(self, stream_name=stream_name, stream_index=stream_index)\n\n    def build_input_flags(self) -&gt; list[str]:\n        \"\"\"\n        Builds the FFmpeg input flags for the video file.\n\n        This method constructs the FFmpeg command line input flags to specify \n        the video file to be processed.\n\n        Returns:\n            list[str]: A list of input flags for FFmpeg, including the file path.\n        \"\"\"\n        command = self.build()\n        command.extend([\"-i\", self.filepath])\n        return command\n\n    def subclip(self, start: float, end: float):\n        \"\"\"\n        Defines a subclip from the video file by setting the start and end times.\n\n        Args:\n            start (float): The start time of the subclip in seconds.\n            end (float): The end time of the subclip in seconds.\n\n        Returns:\n            VideoFile: The updated VideoFile object with the subclip flags set.\n        \"\"\"\n        self.flags.update(((\"ss\", start), (\"t\", end)))\n        return self\n\n    @classmethod\n    def from_imagefile(cls, imgpath: str, duration: float, fps: int):\n        \"\"\"\n        Creates a VideoFile object from an image file, looping it for the given \n        duration and setting the frame rate.\n\n        Args:\n            imgpath (str): The path to the image file to use as a video.\n            duration (float): The duration of the video in seconds.\n            fps (int): The frame rate of the video.\n\n        Returns:\n            VideoFile: A VideoFile object created from the image file.\n        \"\"\"\n        c = cls(imgpath)\n        c.flags[\"loop\"] = 1\n        c.flags[\"t\"] = duration\n        c.flags[\"framerate\"] = fps\n        return c\n\n\n    def get_size(self):\n        \"\"\"\n        Retrieves the resolution (width and height) of the video file.\n\n        Uses FFprobe to extract the width and height of the first video stream \n        in the video file.\n\n        Returns:\n            tuple[int, int]: A tuple containing the width and height of the video.\n        \"\"\"\n        data = ffprobe(\n            self.filepath,\n            (\n                \"-v\",\n                \"error\",\n                \"-select_streams\",\n                \"v:0\",\n                \"-show_entries\",\n                \"stream=width,height\",\n            ),\n        )[\"streams\"][0]\n        return data[\"width\"], data[\"height\"]\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;VideoFile filepath={self.filepath}&gt;\"\n</code></pre>"},{"location":"api/#ffmpeg.inputs.VideoFile.audio","title":"<code>audio</code>  <code>property</code>","text":"<p>Access the audio stream of the video file.</p> <p>Returns:</p> Name Type Description <code>StreamSpecifier</code> <code>StreamSpecifier</code> <p>A StreamSpecifier object for the audio stream.</p>"},{"location":"api/#ffmpeg.inputs.VideoFile.subtitle","title":"<code>subtitle</code>  <code>property</code>","text":"<p>Access the subtitle stream of the video file.</p> <p>Returns:</p> Name Type Description <code>StreamSpecifier</code> <code>StreamSpecifier</code> <p>A StreamSpecifier object for the subtitle stream.</p>"},{"location":"api/#ffmpeg.inputs.VideoFile.video","title":"<code>video</code>  <code>property</code>","text":"<p>Access the video stream of the video file.</p> <p>Returns:</p> Name Type Description <code>StreamSpecifier</code> <code>StreamSpecifier</code> <p>A StreamSpecifier object for the video stream.</p>"},{"location":"api/#ffmpeg.inputs.VideoFile.__init__","title":"<code>__init__(filepath)</code>","text":"<p>Initializes the VideoFile object with the specified file path.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>The path to the video file to be processed.</p> required Source code in <code>ffmpeg\\inputs\\video.py</code> <pre><code>def __init__(self, filepath: str) -&gt; None:\n    \"\"\"\n    Initializes the VideoFile object with the specified file path.\n\n    Args:\n        filepath (str): The path to the video file to be processed.\n    \"\"\"\n    super().__init__()\n    self.filepath = filepath\n</code></pre>"},{"location":"api/#ffmpeg.inputs.VideoFile.build_input_flags","title":"<code>build_input_flags()</code>","text":"<p>Builds the FFmpeg input flags for the video file.</p> <p>This method constructs the FFmpeg command line input flags to specify  the video file to be processed.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: A list of input flags for FFmpeg, including the file path.</p> Source code in <code>ffmpeg\\inputs\\video.py</code> <pre><code>def build_input_flags(self) -&gt; list[str]:\n    \"\"\"\n    Builds the FFmpeg input flags for the video file.\n\n    This method constructs the FFmpeg command line input flags to specify \n    the video file to be processed.\n\n    Returns:\n        list[str]: A list of input flags for FFmpeg, including the file path.\n    \"\"\"\n    command = self.build()\n    command.extend([\"-i\", self.filepath])\n    return command\n</code></pre>"},{"location":"api/#ffmpeg.inputs.VideoFile.from_imagefile","title":"<code>from_imagefile(imgpath, duration, fps)</code>  <code>classmethod</code>","text":"<p>Creates a VideoFile object from an image file, looping it for the given  duration and setting the frame rate.</p> <p>Parameters:</p> Name Type Description Default <code>imgpath</code> <code>str</code> <p>The path to the image file to use as a video.</p> required <code>duration</code> <code>float</code> <p>The duration of the video in seconds.</p> required <code>fps</code> <code>int</code> <p>The frame rate of the video.</p> required <p>Returns:</p> Name Type Description <code>VideoFile</code> <p>A VideoFile object created from the image file.</p> Source code in <code>ffmpeg\\inputs\\video.py</code> <pre><code>@classmethod\ndef from_imagefile(cls, imgpath: str, duration: float, fps: int):\n    \"\"\"\n    Creates a VideoFile object from an image file, looping it for the given \n    duration and setting the frame rate.\n\n    Args:\n        imgpath (str): The path to the image file to use as a video.\n        duration (float): The duration of the video in seconds.\n        fps (int): The frame rate of the video.\n\n    Returns:\n        VideoFile: A VideoFile object created from the image file.\n    \"\"\"\n    c = cls(imgpath)\n    c.flags[\"loop\"] = 1\n    c.flags[\"t\"] = duration\n    c.flags[\"framerate\"] = fps\n    return c\n</code></pre>"},{"location":"api/#ffmpeg.inputs.VideoFile.get_size","title":"<code>get_size()</code>","text":"<p>Retrieves the resolution (width and height) of the video file.</p> <p>Uses FFprobe to extract the width and height of the first video stream  in the video file.</p> <p>Returns:</p> Type Description <p>tuple[int, int]: A tuple containing the width and height of the video.</p> Source code in <code>ffmpeg\\inputs\\video.py</code> <pre><code>def get_size(self):\n    \"\"\"\n    Retrieves the resolution (width and height) of the video file.\n\n    Uses FFprobe to extract the width and height of the first video stream \n    in the video file.\n\n    Returns:\n        tuple[int, int]: A tuple containing the width and height of the video.\n    \"\"\"\n    data = ffprobe(\n        self.filepath,\n        (\n            \"-v\",\n            \"error\",\n            \"-select_streams\",\n            \"v:0\",\n            \"-show_entries\",\n            \"stream=width,height\",\n        ),\n    )[\"streams\"][0]\n    return data[\"width\"], data[\"height\"]\n</code></pre>"},{"location":"api/#ffmpeg.inputs.VideoFile.get_stream","title":"<code>get_stream(stream_index, stream_name=None)</code>","text":"<p>Get a specific stream from the video file by index and/or stream name. </p> Example <p>You get 2nd audio stream from video like this.  <pre><code>clip.get_stream(stream_index=1,stream_name=\"a\")\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>stream_index</code> <code>int</code> <p>The index of the stream (e.g., 0 for the first stream).</p> required <code>stream_name</code> <code>Optional[Literal['a', 'v', 's']]</code> <p>The name of the stream  to retrieve (\"a\" for audio, \"v\" for video, \"s\" for subtitles).  If not provided, retrieves the stream by index.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>StreamSpecifier</code> <code>StreamSpecifier</code> <p>A StreamSpecifier object for the requested stream.</p> Source code in <code>ffmpeg\\inputs\\video.py</code> <pre><code>def get_stream(\n    self,\n    stream_index: int,\n    stream_name: Optional[Literal[\"a\", \"v\", \"s\"]] = None,\n) -&gt; StreamSpecifier:\n    \"\"\"\n    Get a specific stream from the video file by index and/or stream name. \n\n    Example:\n        You get 2nd audio stream from video like this. \n        ```python \n        clip.get_stream(stream_index=1,stream_name=\"a\")\n        ```\n\n    Args:\n        stream_index (int): The index of the stream (e.g., 0 for the first stream).\n        stream_name (Optional[Literal[\"a\", \"v\", \"s\"]]): The name of the stream \n            to retrieve (\"a\" for audio, \"v\" for video, \"s\" for subtitles). \n            If not provided, retrieves the stream by index.\n\n    Returns:\n        StreamSpecifier: A StreamSpecifier object for the requested stream.\n    \"\"\"\n    return StreamSpecifier(self, stream_name=stream_name, stream_index=stream_index)\n</code></pre>"},{"location":"api/#ffmpeg.inputs.VideoFile.subclip","title":"<code>subclip(start, end)</code>","text":"<p>Defines a subclip from the video file by setting the start and end times.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>float</code> <p>The start time of the subclip in seconds.</p> required <code>end</code> <code>float</code> <p>The end time of the subclip in seconds.</p> required <p>Returns:</p> Name Type Description <code>VideoFile</code> <p>The updated VideoFile object with the subclip flags set.</p> Source code in <code>ffmpeg\\inputs\\video.py</code> <pre><code>def subclip(self, start: float, end: float):\n    \"\"\"\n    Defines a subclip from the video file by setting the start and end times.\n\n    Args:\n        start (float): The start time of the subclip in seconds.\n        end (float): The end time of the subclip in seconds.\n\n    Returns:\n        VideoFile: The updated VideoFile object with the subclip flags set.\n    \"\"\"\n    self.flags.update(((\"ss\", start), (\"t\", end)))\n    return self\n</code></pre>"},{"location":"api/#ffmpeg.filters.BaseFilter","title":"<code>BaseFilter</code>","text":"<p>Base class for all FFmpeg filters.</p> Source code in <code>ffmpeg\\filters\\base.py</code> <pre><code>class BaseFilter:\n    \"\"\"Base class for all FFmpeg filters.\"\"\"\n\n    def __init__(self, filter_name: str) -&gt; None:\n\n        self.filter_name = filter_name\n        self.flags: dict = {}  # all args\n\n        self.parent_nodes: list[\"BaseInput\" | BaseFilter | StreamSpecifier] = []\n        self.parent_stream: list[int | str | None] = []\n\n        self.output_count = 1\n\n    def add_input(self, node: Union[\"BaseInput\", \"BaseFilter\"]):\n        self.parent_nodes.append(node)\n\n    def build(self) -&gt; str:\n        s = []\n        for k, v in self.flags.items():\n            s.append(f\"{k}={v}\")\n\n        return f\"{self.filter_name}=\" + (\":\".join(s))\n\n    def get_outputs(self):\n        return (\n            StreamSpecifier(self)\n            if self.output_count == 1\n            else [StreamSpecifier(self, i) for i in range(self.output_count)]\n        )\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{self.__class__.__name__}, flags={self.flags}&gt;\"  # TODO get better printing scheme\n</code></pre>"},{"location":"api/#ffmpeg.filters.Concat","title":"<code>Concat</code>","text":"<p>               Bases: <code>BaseFilter</code></p> <p>Represents an overlay filter that combines streams.</p> Source code in <code>ffmpeg\\filters\\concat.py</code> <pre><code>class Concat(BaseFilter):\n    \"\"\"\n    Represents an overlay filter that combines streams.\n\n    \"\"\"\n\n    def __init__(self, nodes:list):\n        super().__init__(\"concat\")\n        self.clips = nodes\n        self.parent_nodes = []\n        self.flags[\"n\"] = len(self.clips)  + 1 # assuming the first one is from apply fucution\n        self.flags[\"v\"] = 1\n\n    def get_outputs(self):\n        if self.clips != self.parent_nodes:\n            self.parent_nodes.extend(self.clips)\n\n        return (\n            StreamSpecifier(self)\n            if self.output_count == 1\n            else [StreamSpecifier(self, i) for i in range(self.output_count)]\n        )\n</code></pre>"},{"location":"api/#ffmpeg.filters.Overlay","title":"<code>Overlay</code>","text":"<p>               Bases: <code>BaseFilter</code>, <code>TimelineEditingMixin</code></p> <p>Represents an overlay filter that combines two video streams.</p> Source code in <code>ffmpeg\\filters\\overlay.py</code> <pre><code>class Overlay(BaseFilter, TimelineEditingMixin):\n    \"\"\"\n    Represents an overlay filter that combines two video streams.\n\n    \"\"\"\n\n    def __init__(self, overlay_input: Optional[\"BaseInput\"], x: int, y: int):\n        super().__init__(\"overlay\")\n        self.overlay_node = overlay_input\n        self.flags[\"x\"] = x\n        self.flags[\"y\"] = y\n\n        # Expecting two inputs by default (background and overlay)\n\n    def get_outputs(self):\n        if self.overlay_node not in self.parent_nodes:\n            self.parent_nodes.append(self.overlay_node)\n\n        return (\n            StreamSpecifier(self)\n            if self.output_count == 1\n            else [StreamSpecifier(self, i) for i in range(self.output_count)]\n        )\n</code></pre>"},{"location":"api/#ffmpeg.filters.Transition","title":"<code>Transition</code>","text":"<p>               Bases: <code>BaseFilter</code></p> Source code in <code>ffmpeg\\filters\\transition.py</code> <pre><code>class Transition(BaseFilter):\n    all_transitions = (\n        \"custom\",\n        \"fade\",\n        \"wipeleft\",\n        \"wiperight\",\n        \"wipeup\",\n        \"wipedown\",\n        \"slideleft\",\n        \"slideright\",\n        \"slideup\",\n        \"slidedown\",\n        \"circlecrop\",\n        \"rectcrop\",\n        \"distance\",\n        \"fadeblack\",\n        \"fadewhite\",\n        \"radial\",\n        \"smoothleft\",\n        \"smoothright\",\n        \"smoothup\",\n        \"smoothdown\",\n        \"circleopen\",\n        \"circleclose\",\n        \"vertopen\",\n        \"vertclose\",\n        \"horzopen\",\n        \"horzclose\",\n        \"dissolve\",\n        \"pixelize\",\n        \"diagtl\",\n        \"diagtr\",\n        \"diagbl\",\n        \"diagbr\",\n        \"hlslice\",\n        \"hrslice\",\n        \"vuslice\",\n        \"vdslice\",\n        \"hblur\",\n        \"fadegrays\",\n        \"wipetl\",\n        \"wipetr\",\n        \"wipebl\",\n        \"wipebr\",\n        \"squeezeh\",\n        \"squeezev\",\n        \"zoomin\",\n        \"fadefast\",\n        \"fadeslow\",\n        \"hlwind\",\n        \"hrwind\",\n        \"vuwind\",\n        \"vdwind\",\n        \"coverleft\",\n        \"coverright\",\n        \"coverup\",\n        \"coverdown\",\n        \"revealleft\",\n        \"revealright\",\n        \"revealup\",\n        \"revealdown\",\n    )\n\n    def __init__(\n        self, name: str, offset: float = 0, duration: float = 1, expression=None\n    ):\n        \"\"\"\n        Combine two videos with transition.Note: requires same size and fps and aspect ration\n        \"\"\"\n        super().__init__(\"xfade\")\n\n        if name == \"custom\" and not isinstance(expression, str):\n            raise TypeError(\"Expression must be a string\")\n\n        if name not in self.all_transitions:\n            raise TypeError(\"Transtion name should \", self.all_transitions)\n\n        self.flags = {\"transition\": name, \"offset\": offset, \"duration\": duration}\n</code></pre>"},{"location":"api/#ffmpeg.filters.Transition.__init__","title":"<code>__init__(name, offset=0, duration=1, expression=None)</code>","text":"<p>Combine two videos with transition.Note: requires same size and fps and aspect ration</p> Source code in <code>ffmpeg\\filters\\transition.py</code> <pre><code>def __init__(\n    self, name: str, offset: float = 0, duration: float = 1, expression=None\n):\n    \"\"\"\n    Combine two videos with transition.Note: requires same size and fps and aspect ration\n    \"\"\"\n    super().__init__(\"xfade\")\n\n    if name == \"custom\" and not isinstance(expression, str):\n        raise TypeError(\"Expression must be a string\")\n\n    if name not in self.all_transitions:\n        raise TypeError(\"Transtion name should \", self.all_transitions)\n\n    self.flags = {\"transition\": name, \"offset\": offset, \"duration\": duration}\n</code></pre>"},{"location":"api/#ffmpeg.filters.apply","title":"<code>apply(node, *parent)</code>","text":"<p>Apply a filter input streams.</p> <p>This function connects the given input nodes (either BaseInput or StreamSpecifier) to a filter node and returns a single output stream from the filter.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>BaseFilter</code> <p>The filter node to apply.</p> required <code>*parent</code> <code>BaseInput | StreamSpecifier</code> <p>Input nodes to connect to the filter.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>StreamSpecifier</code> <code>StreamSpecifier</code> <p>The resulting single output stream from the filter.</p> Source code in <code>ffmpeg\\filters\\apply_filter.py</code> <pre><code>def apply(\n    node: BaseFilter,\n    *parent: BaseInput | StreamSpecifier,\n) -&gt; StreamSpecifier:\n    \"\"\"\n    Apply a filter input streams.\n\n    This function connects the given input nodes (either BaseInput or StreamSpecifier)\n    to a filter node and returns a single output stream from the filter.\n\n    Args:\n        node (BaseFilter): The filter node to apply.\n        *parent (BaseInput | StreamSpecifier): Input nodes to connect to the filter.\n\n    Returns:\n        StreamSpecifier: The resulting single output stream from the filter.\n    \"\"\"\n    node.parent_nodes.extend(parent)\n    return node.get_outputs()  # type: ignore\n</code></pre>"},{"location":"api/#ffmpeg.filters.apply2","title":"<code>apply2(node, *parent)</code>","text":"<p>Apply a filter input streams.</p> <p>This function connects the given input nodes (either BaseInput or StreamSpecifier) to a filter node and returns a list of all output streams from the filter.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>BaseFilter</code> <p>The filter node to apply.</p> required <code>*parent</code> <code>BaseInput | StreamSpecifier</code> <p>Input nodes to connect to the filter.</p> <code>()</code> <p>Returns:</p> Type Description <code>list[StreamSpecifier]</code> <p>list[StreamSpecifier]: A list of output streams from the filter.</p> Source code in <code>ffmpeg\\filters\\apply_filter.py</code> <pre><code>def apply2(\n    node: BaseFilter,\n    *parent: BaseInput | StreamSpecifier,\n) -&gt; list[StreamSpecifier]:\n    \"\"\"\n    Apply a filter input streams.\n\n    This function connects the given input nodes (either BaseInput or StreamSpecifier)\n    to a filter node and returns a list of all output streams from the filter.\n\n    Args:\n        node (BaseFilter): The filter node to apply.\n        *parent (BaseInput | StreamSpecifier): Input nodes to connect to the filter.\n\n    Returns:\n        list[StreamSpecifier]: A list of output streams from the filter.\n    \"\"\"\n    node.parent_nodes.extend(parent)\n    return node.get_outputs()  # type: ignore\n</code></pre>"},{"location":"api/#ffmpeg.utils.build_flags","title":"<code>build_flags(kwflags)</code>","text":"<p>Generate flags</p> Source code in <code>ffmpeg\\utils\\commons.py</code> <pre><code>def build_flags(kwflags: dict[str, Any]) -&gt; list[str]:\n    \"\"\"Generate flags\"\"\"\n    flags = []\n\n    for k, v in kwflags.items():\n        flags.append(f\"-{k}\")\n        flags.append(str(v))\n\n    return flags\n</code></pre>"},{"location":"api/#ffmpeg.utils.parse_value","title":"<code>parse_value(value)</code>","text":"<p>Convert FFmpeg progress values to appropriate data types.</p> Source code in <code>ffmpeg\\utils\\commons.py</code> <pre><code>def parse_value(value):\n    \"\"\"Convert FFmpeg progress values to appropriate data types.\"\"\"\n    if value.isdigit():\n        return int(value)\n    try:\n        return float(value)\n    except ValueError:\n        return value\n</code></pre>"},{"location":"api/#ffmpeg.exception.FFmpegException","title":"<code>FFmpegException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when an FFmpeg command fails.</p> <p>Attributes:</p> Name Type Description <code>msg</code> <code>str</code> <p>The error message returned by FFmpeg.</p> <code>return_code</code> <code>int</code> <p>The process return code from FFmpeg.</p> Source code in <code>ffmpeg\\exception\\exceptions.py</code> <pre><code>class FFmpegException(Exception):\n    \"\"\"\n    Exception raised when an FFmpeg command fails.\n\n    Attributes:\n        msg (str): The error message returned by FFmpeg.\n        return_code (int): The process return code from FFmpeg.\n    \"\"\"\n    def __init__(self, msg, return_code) -&gt; None:\n        \"\"\"\n        Initialize FFmpegException.\n\n        Args:\n            msg (str): Error message from FFmpeg.\n            return_code (int): Return code from FFmpeg process.\n        \"\"\"\n        self.msg = msg\n        self.return_code = return_code\n\n    def __str__(self) -&gt; str:\n        return f\"FFmpegException Message:\\n\\n{self.msg}\"\n</code></pre>"},{"location":"api/#ffmpeg.exception.FFmpegException.__init__","title":"<code>__init__(msg, return_code)</code>","text":"<p>Initialize FFmpegException.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>Error message from FFmpeg.</p> required <code>return_code</code> <code>int</code> <p>Return code from FFmpeg process.</p> required Source code in <code>ffmpeg\\exception\\exceptions.py</code> <pre><code>def __init__(self, msg, return_code) -&gt; None:\n    \"\"\"\n    Initialize FFmpegException.\n\n    Args:\n        msg (str): Error message from FFmpeg.\n        return_code (int): Return code from FFmpeg process.\n    \"\"\"\n    self.msg = msg\n    self.return_code = return_code\n</code></pre>"},{"location":"api/#ffmpeg.exception.FFprobeException","title":"<code>FFprobeException</code>","text":"<p>               Bases: <code>FFmpegException</code></p> <p>Exception raised when an FFprobe command fails.</p> <p>Inherits from FFmpegException and is specific to FFprobe failures.</p> <p>Attributes:</p> Name Type Description <code>msg</code> <code>str</code> <p>The error message returned by FFprobe.</p> <code>return_code</code> <code>int</code> <p>The process return code from FFprobe.</p> Source code in <code>ffmpeg\\exception\\exceptions.py</code> <pre><code>class FFprobeException(FFmpegException):\n    \"\"\"\n    Exception raised when an FFprobe command fails.\n\n    Inherits from FFmpegException and is specific to FFprobe failures.\n\n    Attributes:\n        msg (str): The error message returned by FFprobe.\n        return_code (int): The process return code from FFprobe.\n    \"\"\"\n    def __init__(self, msg, return_code) -&gt; None:\n        \"\"\"\n        Initialize FFprobeException.\n\n        Args:\n            msg (str): Error message from FFprobe.\n            return_code (int): Return code from FFprobe process.\n        \"\"\"\n        self.msg = msg\n        self.return_code = return_code\n\n    def __str__(self) -&gt; str:\n        return f\"FFprobeException Message:\\n\\n{self.msg}\"\n</code></pre>"},{"location":"api/#ffmpeg.exception.FFprobeException.__init__","title":"<code>__init__(msg, return_code)</code>","text":"<p>Initialize FFprobeException.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>Error message from FFprobe.</p> required <code>return_code</code> <code>int</code> <p>Return code from FFprobe process.</p> required Source code in <code>ffmpeg\\exception\\exceptions.py</code> <pre><code>def __init__(self, msg, return_code) -&gt; None:\n    \"\"\"\n    Initialize FFprobeException.\n\n    Args:\n        msg (str): Error message from FFprobe.\n        return_code (int): Return code from FFprobe process.\n    \"\"\"\n    self.msg = msg\n    self.return_code = return_code\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This library provides a Pythonic interface to FFmpeg, making it easier to handle video and audio processing. Below is a quick guide to get you started using FFmpeg.py with minimal code.</p> <p>FFmpeg.py comes with an easy-to-use <code>export</code> function that export the single output with multiple stream.</p> <p>Here quickly combine audio and video from files and output them to a single file.</p> <pre><code>from ffmpeg.inputs import VideoFile\nfrom ffmpeg import export\n\nexport(\n    VideoFile(\"video1.mp4\").video,  # Video stream from video.mp4\n    VideoFile(\"video2.mp4\").audio,  # Audio stream from video1.mp4\n    path=\"out.mp4\",  # Output path\n).run()\n\n# ffmpeg ... -i video1.mp4 -i video2.mp4 -map 0:v -map 1:a out.mp4\n</code></pre> <p>This code extracts the video from <code>video.mp4</code> and the audio from <code>video1.mp4</code>, then exports them into a single output file <code>out.mp4</code>.</p> <p>Which is same as Using <code>FFmpeg()</code> with <code>Map</code> but in this way you can add flags per <code>Map</code> like encoding.</p> <pre><code>from ffmpeg.inputs import VideoFile\nfrom ffmpeg import FFmpeg, Map\n\nFFmpeg().output(\n    Map(VideoFile(\"video.mp4\").video),  # Map video stream from video.mp4\n    Map(VideoFile(\"video1.mp4\").audio),  # Map audio stream from video1.mp4\n    path=\"out.mp4\",  # Output path\n).run()\n# ffmpeg ... -i video.mp4 -i video1.mp4 -map 0:v -map 1:a out.mp4\n</code></pre> <p>Tip</p> <p>This method provides a more explicit control flow where each stream is mapped individually. you can provide flags for <code>-map</code> context with both stream suffixed flag or without. </p>"},{"location":"getting-started/#example","title":"Example","text":"<p>Lets make a video from a image with audio with</p> <pre><code>from ffmpeg.ffmpeg import FFmpeg\nfrom ffmpeg.inputs import FileInputOptions, InputFile\nfrom ffmpeg.models.output import Map\n\n# set options\nclip = InputFile(\n    \"image.png\",\n    FileInputOptions(loop=True, duration=5, frame_rate=60),\n)\naudio = InputFile(\n    \"audio.mp3\",\n    FileInputOptions(duration=5),\n)\n\n# run command\nffmpeg = (\n    FFmpeg().output(Map(clip), Map(audio), path=\"out.mp4\").run()\n)\n\n# ffmpeg ... -t 5 -r 60 -loop 1 -i image.png -t 5 -i audio.mp3 -map 0 -map 1 out.mp4\n</code></pre> <p>Here we are using <code>InputFile</code> it is for generic input which are support by FFmpeg like path or url in combination with <code>FileInputOptions</code> this provide useful flags that are applied to input in ffmpeg command.</p> <p>The above code is easy to understand which works like:</p> <ul> <li><code>loop=True</code> will make a infinite loop</li> <li>we set a <code>duration</code> so infinite loop can end</li> <li>then set <code>frame_rate</code> at 60</li> </ul>"},{"location":"getting-started/#filters","title":"Filters","text":"<p>Filters can be used with  <code>apply</code> or <code>apply2</code>, apply2 is for multi output filters like Split and Concat.</p> <p>Usage:</p> <pre><code>clip = InputFile(\"image.png\")\nclip_scaled = apply(Scale(1000, 1000), clip)\n</code></pre> <p>Lets scale the image and then use it:</p> <p>At end we make a FFmpeg and add a output with two stream mapping. The <code>Map</code> add stream(s) to a output file in this way we can add multiple streams to one output, for more complex use case see Advance Usage like Filtering, Multiple outputs or what is progress_callback.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#install-library","title":"Install Library","text":"<pre><code>pip install git+https://github.com/electro199/ffmpeg.py.git\n</code></pre> <p>Note</p> <p>This project does not install ffmpeg utility automatically. </p>"},{"location":"installation/#install-ffmpeg","title":"Install FFmpeg","text":"<p>Use any of these methods:</p>"},{"location":"installation/#windows","title":"Windows","text":"<p>Using winget: <pre><code>winget install --id=Gyan.FFmpeg  -e\n</code></pre></p> <p>or download and install FFmpeg from FFmpeg official website:</p> <ol> <li>Download the latest FFmpeg build from here.</li> <li>Extract the archive and add the <code>bin</code> directory to your system <code>PATH</code>.</li> </ol>"},{"location":"installation/#linux","title":"Linux","text":"<p>For Debian/Ubuntu: <pre><code>sudo apt install ffmpeg\n</code></pre></p>"},{"location":"installation/#macos","title":"MacOS","text":"<p>Using Homebrew: <pre><code>brew install ffmpeg\n</code></pre></p>"},{"location":"installation/#verify-installation","title":"Verify installation","text":"<pre><code>ffmpeg -version\n</code></pre>"},{"location":"useful_info/","title":"Useful info","text":""},{"location":"useful_info/#ffmpeg-command-structure","title":"FFMPEG command structure","text":"<p>The FFmpeg have very complex command structure the position of flags can effect the output come. The command is mainly consist of input which can be be media (file/link on internet/or any supported protocol that ffmpeg supports), then optional filter flag that tell how input should be manipulated then map flag to set which stream should be used in output either the input file and/or the modified stream the is generated after filtering</p> <p>Lets see the command structure with examples:</p> <ol> <li> <p>ffmpeg command with single input and single output simplest form</p> <ul> <li> <p>structure:</p> <pre><code>ffmpeg [options] [[infile options] -i infile]... [[outfile options] outfile]...\n</code></pre> </li> <li> <p>example with -y to overwrite the </p> <pre><code>ffmpeg -y -t 30 input_file_path.mp4  -r 24 output_file_path.mp4 \n</code></pre> </li> </ul> </li> </ol> <p>usage: ffmpeg [options][[infile options] -i infile]... [filter ]...  [-map [outfile options] outfile]...</p> <p>ffmpeg [infile options] -i infile [-map flags outfile]...</p> <p>multiple input, filter</p>"},{"location":"advance-usage/advance-usage/","title":"Advance usage","text":"<p>Lets see how everything works in FFmpeg.py</p>"},{"location":"advance-usage/advance-usage/#input","title":"Input","text":"<p>The ffmpeg takes input in <code>[-key value -i path]</code>, ffmpeg.py will make a input with <code>InputFile</code> or <code>VideoFile</code>. Both of them are does same thing but with VideoFile it comes with addition features like:</p> <ul> <li>subclip that sets <code>-ss</code> and <code>-t</code>  for seek start and duration repectively</li> <li>from_imagefile  that sets <code>-t</code>  for duration and enable <code>loop</code>.</li> <li>general streams like video, audio and subtitles that corresponds to <code>stream_name:v:n</code>/<code>stream_name:a:n</code>/<code>stream_name:s:n</code> in both filter and map context in command.</li> </ul>"},{"location":"advance-usage/advance-usage/#global-flags","title":"Global flags","text":"<p>Global flags are used change settings for whole runtime, you can use <code>add_global_flag</code> to set custom flags, These flags are automatic added duration command generation in <code>FFmpeg.compile()</code>:</p> <ul> <li><code>-y</code> or <code>-n</code> to set overwrite outfile </li> <li><code>-loglevel error</code> to only read errors</li> <li><code>-hide_banner</code> to avoid extra pipe writes and cleaner output.</li> </ul>"},{"location":"advance-usage/advance-usage/#usage","title":"Usage","text":"<p>The <code>add_global_flag</code> take raw flags example as: <pre><code>FFmpeg().add_global_flag(\"-recast_media\")\n\n## Results ffmpeg -recast_media -i ....\n</code></pre></p>"},{"location":"advance-usage/advance-usage/#filters","title":"Filters","text":"<p>Filters are way the ffmpeg allow media to be manipulated, ffmpeg.py use <code>apply</code> or <code>apply2</code>, apply2 is for multi output filters. Filter output can be exported or further filtered.</p>"},{"location":"advance-usage/advance-usage/#usage_1","title":"Usage","text":"<p>The <code>apply</code> functions take Filter and then the input to be filtered</p> <pre><code>apply(Filter, clip)\n</code></pre>"},{"location":"advance-usage/advance-usage/#example","title":"Example","text":"<p>Lets make a video logo overlay both scaled.</p> <pre><code>from ffmpeg import FFmpeg, Map, InputFile, VideoFile\nfrom ffmpeg.filters import apply, Scale, Overlay\n\n\nlogo = InputFile(\n    \"image.png\",\n)\n\nscaled_logo = apply(Scale(200, 200), logo)\n\nvideo = VideoFile(\n    \"video.mp4\",\n)\n\nscaled_video = apply(Scale(1920, 1080), video)\n\nfinal_video = apply(Overlay(scaled_logo, 0, 0),scaled_video)\n\n\n(\n    FFmpeg()\n    .output(Map(final_video), path=\"out.mp4\")\n    .run()\n)\n# Results \n# ffmpeg -hide_banner -y -loglevel error -i image.png -i video.mp4 \\\n# -filter_complex [0]scale=width=200:height=200[n0o0]; \\\n#                 [1]scale=width=1920:height=1080[n1o0];\\\n#                 [n1o0][n0o0]overlay=x=0:y=0[n2o0] \\\n#  -map [n2o0] out.mp4\n</code></pre>"},{"location":"advance-usage/advance-usage/#multiple-outputs","title":"Multiple Outputs","text":"<p>ffmpeg.py supports multiple output in single command by simply calling one more <code>output</code>. Lets use previous example. Here we are export the video and scaled logo</p> <pre><code>from ffmpeg import FFmpeg, Map, InputFile, VideoFile\nfrom ffmpeg.filters import apply, Scale, Overlay\n\n\nlogo = InputFile(\n    \"image.png\",\n)\n\nscaled_logo = apply(Scale(200, 200), logo)\n\nvideo = VideoFile(\n    \"video.mp4\",\n)\n\nscaled_video = apply(Scale(1920, 1080), video)\n\nfinal_video = apply(Overlay(scaled_logo, 0, 0), scaled_video)\n\n\n(\n    FFmpeg()\n    .output(Map(final_video), path=\"out.mp4\")\n    .output(Map(scaled_logo), path=\"scaled_logo.png\")\n    .run()\n)\n\n# Results \n# ffmpeg -hide_banner -y -loglevel error -i image.png -i video.mp4\n# -filter_complex [0]scale=width=200:height=200[n0o0]; \\\n#                 [1]scale=width=1920:height=1080[n1o0];\\\n#                 [n1o0][n0o0]overlay=x=0:y=0[n2o0]\\\n# -map [n2o0] out.mp4 \n# -map [n0o0] scaled_logo.png\n</code></pre>"},{"location":"advance-usage/advance-usage/#map-flags","title":"Map Flags","text":"<p>We also need to set <code>-map</code> flags when exporting like setting fps or bitrate to do that we will set them in <code>Map</code> context</p> <p>Use <code>suffix_flags</code> when a flags requires a suffix like <code>-r:1</code> or <code>-r:v:1</code> otherwise <code>kwargs</code> will catch all normal flags.</p> <pre><code>(\n    FFmpeg()\n    .output(Map(final_video,), path=\"out.mp4\")\n    .output(Map(scaled_logo), path=\"scaled_logo.png\")\n    .run()\n)\n</code></pre>"},{"location":"advance-usage/useful_info/","title":"Useful info","text":""},{"location":"advance-usage/useful_info/#ffmpeg-command-structure","title":"FFMPEG command structure","text":"<p>The FFmpeg have very complex command structure the position of flags can effect the output come. The command is mainly consist of input which can be be media (file/link on internet/or any supported protocol that ffmpeg supports), then optional filter flag that tell how input should be manipulated then map flag to set which stream should be used in output either the input file and/or the modified stream the is generated after filtering</p> <p>Lets see the command structure with examples:</p> <ol> <li> <p>ffmpeg command with single input and single output simplest form</p> <ul> <li> <p>structure:</p> <pre><code>ffmpeg [options] [[infile options] -i infile]... [[outfile options] outfile]...\n</code></pre> </li> <li> <p>example with -y to overwrite the </p> <pre><code>ffmpeg -y -t 30 input_file_path.mp4  -r 24 output_file_path.mp4 \n</code></pre> </li> </ul> </li> </ol> <p>usage: ffmpeg [options][[infile options] -i infile]... [filter ]...  [-map [outfile options] outfile]...</p> <p>ffmpeg [infile options] -i infile [-map flags outfile]...</p> <p>multiple input, filter</p>"}]}